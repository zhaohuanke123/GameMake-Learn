# 数据结构|算法

数组

排序

快排、堆排、归并排序

# C#基础

## 代码编译执行过程

1. C#源文件经过CSC.exe把Visual C#程序代码编译成IL文件(这里有很多参数和开关选项，编译器编译生成程序集（exe dll）
2. c#代码第一次编译为一种伪代码称微软中间语言(MSIL)和元数据，MSIL和元数据同时储存在exe或dll 文件中，该伪代码是独立于任何CPU 的，所以只要装有.Net FrameWork的机器均可以运行该伪代码，这就增强了c#代码的可移植性。(ps.中间语言IL不是计算机识别语言,此IL文件不能直接被计算机使用)
3. 程序执行时，该伪代码被CLR(Commom Language RunTime)捕获，CLR激活内部的 JIT(Just in time)编译器，将伪代码编译成针对特定CPU的机器语言，当然该步还要进行类型检查等，这样程序就能在任意合理的电脑中运行，得出结果。

JIT 的意思为“仅在运行时编译”，整个代码的处理过程要编译两次。（PS:从IL文件到机器语言，这个工程是机器自动实现的）

JIT 和 AOT

### 值类型和引用类型有何区别？

1.值类型的数据存储在内存的栈中；引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的地址。

2.值类型存取速度快，引用类型存取速度慢。

3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用

4.值类型继承自System.ValueType，引用类型继承自System.Object

5.栈的内存分配是自动释放；而堆在.NET中会有GC来释放

6.值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。

结构体和类有何区别？

结构体是一种值类型，而类是引用类型。（值类型、引用类型是根据数据存储的角度来分的）

值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作

委托是什么？有何用处？

委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法，相当于对一组方法的列表的引用。

用处：使用委托使程序员可以将方法引用封装在委托对象内。然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。

与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的。

## 反射的实现原理

审查元数据并收集关于它的类型信息的能力。

实现原理：在运行时根据程序集及其中的类型得到元数据。

下面是使用步骤：

1. 导入using System.Reflection;
2. Assembly.Load(“程序集”)加载程序集,返回类型是一个Assembly
3. 得到程序集中所有类的名称

# 设计模式

模式并不是一段特定的代码， 而是解决特定问题的一般性概念

## 开闭原则

## 里氏替换原则

## **状态模式**

在游戏中，角色、AI和游戏状态的管理很常见。

使用状态模式可以使状态转换清晰明确，易于理解和维护。通过将每个状态抽象为一个类，能够轻松地添加新的状态，而不影响到其他部分的代码。

**有限状态机**

## 对象池：

> 对象池是什么：对象池是常用的设计模式之一。它可以减少从头创建每个对象的系统开销。

其核心是：在使用对象前先进行预热，使用的时候从池内拿出来，使用结束后反回池里，而不是销毁。在Unity中的具体实现中，它把Destroy"改"为DeActive了。

对象池意义是将游戏中反复创建销毁的对象进行多次利用，从而避免大量对象的销毁与创建而造成CPU的负担。

缺点是占用了更多的内存，但凡事都没有最好的解决办法，在移动平台上针对游戏的优化基本偏向于牺牲空间换取时间

## 工厂方法模式

> 工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

## 观察者模式

# 引擎相关

## Unity生命周期

Awake——>OnEnable–>Start——>FixedUpdate——>Update——>LateUpdate——>OnGUI——>OnDisable——>OnDestroy

## Unity API使用

如何制作不规则按钮，判断点击

继承Image，然后

```csharp
protected override void Awake () {
	base.Awake () ;
 	alphaHitTestMinimumThreshold = 0. 1f;
}
```

将不规则材质的Read/Wirte打开

移动相机动作应该在哪个函数里，为什么在这个函数里？

LateUpdate，是在所有的update结束后才调用，比较适合用于命令脚本的执行。

官网上例子是摄像机的跟随，都是所有的update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。

### 导航网格（NavMesh）

> 一种用于实现自动寻址的网格，生成寻路所需要的信息

基础

> A*算法

**F = G（到指定节点需要代价） + H（指定节点到目标节点预估代价）**

GC（垃圾回收）产生的原因，并描述如何避免？

GC回收堆上的内存

避免：

1. 减少new产生对象的次数
2. 使用公用的对象（静态成员）
3. 将String换为StringBuilder

JPEG，全称Joint Photographic Experts Group，有损压缩格式

图像压缩格式，压缩好的输出文件，后缀是 jpeg 或者 jpg

PNG，全称Portable Network Graphic Format，可移植网络图形格式、无损压缩格式

重复保存而不降低图像质量（所以，只要不是需要动画效果的地方强烈建议都采用PNG格式图片）

jpeg是有损压缩，png是无损的。正因如此，同一图像质量，png文件的大小，大于jpeg文件。

png支持透明效果（alpha），jpeg不支持。

## **Unity性能优化**

大的方面来说，通过 `Unity`对于项目的性能优化大概可以分为下面几个部分：

* 资源
* 渲染
* 程序
* 项目配置

从性能优化的角度看，**纹理**导入需要遵循如下的原则：

* 降低最大分辨率
* 采用二次幂压缩格式：
* 制作纹理图集
* 取消勾选 `Read/Write Enabled`
* 禁用多余的 `Mip Map`：`Mip Map`贴图在2D精灵和 `UI`图形这类大小始终一直的纹理上并无用处

![1700225483830](image/技术栈/1700225483830.png)

* 高品质压缩格式：`RGBA32`作为一种高保真的压缩格式，能够极大的保证图片质量
* 中品质压缩格式：`RGBA16` + `Dithering`一听就是 `RGBA32`的阉割版，简单来说，相比于 `RGBA32`其色彩细分程度大，可以明显的看出阶梯感，视觉表现相对于 `RGB32`不够平滑
* 低品质压缩格式： `ETC1`+`Alpha`/`PVRTC4`这些压缩格式往往是移动段最常用的压缩格式，其相对于其他压缩格式有着无可比拟的性能优势

> 注意：

* 除了由于压缩逻辑不同带来的加载带宽减少之外，同时还需要了解像 `ETC1`、`PVRTC4`等这类在内存中不需要进行解压，而是可以直接被 `GPU`支持，所以相比其他压缩格式通常会有最好的性能表现

#### HUD系统优化

### 项目打包

资源打包 AssetBundle

作用：

1. DLC
2. 减少初始包大小
3. 版本更新
4. 加载未用户平台优化的资源
5. 减少运行时内存压力

> 压缩选项

* 不压缩：AB包比较大，下载较慢，加载速度快（CPU不用运算解压缩）
* LZMA算法压缩：默认压缩模式，流压缩方式（stream-based），文件尺寸居中，加载速度居中；使用LZMA算法压缩， **压缩的包更小，但是加载时间更长** ，只支持顺序读取。使用之前需要整体解压。一旦被解压，这个包会使用LZ4重新压缩。使用资源的时候不需要整体解压。在下载的时候可以使用LZMA算法，一旦它被下载了之后，它会使用LZ4算法保存到本地上。
* LZ4算法压缩：5.3以后可用，块压缩方式（chunk-based） **压缩比例高，文件小，加载速度偏慢** ；使用LZ4压缩，压缩率没有LZMA高，但是我们可以加载指定资源而不用解压全部，可以实现实时解压随机存储。

分配策略

> 按类型分组：
>
> 强类型相关
>
> 平台相关
>
> 本地化相关
>
> 无交叉依赖

特效纹理

> 按并发分组：
>
> 加载时机一致
>
> 无交叉依赖

> 按逻辑单元分组：
>
> 逻辑功能
>
> 逻辑对象
>
> 共享对象

其他：

频繁更新的对象进行拆分

同时加载的对象打包到一起

拆分加载时机不一致的Bundle

合并频繁加载的小粒度Bundle

#### 资源加载模块：

AB加载方式：

AssetBundle.LoadFromMenory 从内存加载，加密，自定义包体

其他一般情况下使用

LoadFromStreamAsync 流加载，边下载边加载 （性能最佳选择）/

模块设计： 需求-> 设计 -> 实现

> 考虑

发布平台

动态更新 / 流式加载

压缩加密 （安全性）

自定义数据包

> 目标：

PC/移动（跨平台）

资源路径问题：

API：

dataPath

IOS 指向 /`<AppName.app>/Data`

Android  指向 apk文件（压缩包内）

路径规划：

包内： StreamingAssetPath

补丁：persistentDataPath

下载缓存：CachePath

persistentDataPath

IOS 指向 Documents目录（对文档大小有限制，IOS系统会自动备份该目录）（建议：只能玩家产生的数据文件，不要用于实时下载资源）

Android  `/data/` `<packagename>/files ` 中，可以用，没问题

![1700292253415](image/技术栈/1700292253415.png)

实现更新

无加密

自定义包

模块设计

![1700292743647](image/技术栈/1700292743647.png)

流程：

![1700292806035](image/技术栈/1700292806035.png)

补丁目录包括：

补丁资源，补丁清单（版本号，版本资源，资源哈希值）

#### Bundle依赖管理！

### 自动更新系统

> 版本信息管理

1 版本号： 主版本号（重大更新）-次要版本号（小更新） -修正版本号（修复BUG） -测试版本号

规则（根据更新频次）

2 版本记录： 不同服不同版本

3 资源清单： 资源文件，哈希值

3 版本内容： 资源内容

> 更新策略

![1700294634410](image/技术栈/1700294634410.png)

> 更新环境

持续集成CI

Jenkins，Bamboo，Gitlab CI

DevOps

更新服务器

根据需求选择 Updates 放什么压缩包或者目录（做一个版本一个版本更还是一次性更？）

![1700295552708](image/技术栈/1700295552708.png)

框架：

IIS，Apache，Nginx

版本生成工具 - DIY

客户端更新 ~~服务器更新~~

### 项目管理

> git

> large file store

### 项目导出

安卓

### UNITY3d在移动设备上的一些优化资源的方法

IOS

## 多人协同

meta文件管理

每当你往Unity的Assets文件夹下添加一个文件或文件夹时，Unity会默认为其生成一个同名带.meta后缀的文件。

这些.meta文件往往存储了这个资源文件的id（id是资源引用的凭据）、压缩格式等信息。

# 图形学

## 基础

矩阵乘法

仿射变换

正交变换

欧拉角

四元数

相对欧拉角的优点：

1. 能进行增量旋转
2. 避免万向锁
3. 给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式）

相机深度

## 渲染过程
