## 进程分配内存的两种方式——brk()和mmap()

当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：
1、检查要访问的虚拟地址是否合法
2、查找/分配一个物理页
3、填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）
4、建立映射关系（虚拟地址到物理地址）
重新执行发生缺页中断的那条指令


从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。

1、brk是将数据段(.data)的最高地址指针_edata往高地址推；

2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。

这两种方式分配的都是虚拟内存，没有分配物理内存。

在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。

在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。



## malloc 和 new的区别

malloc怎么分配空间

malloc分配的物理内存还是虚拟内存？
malloc调用后是否立刻得到物理内存?
free（p），怎么知道该释放多大的空间？

free释放内存后，内存还在吗

break对应堆区

mmap对于文件映射区

malloc、freec语言中库函数，new、delete是c+中操作符
new自动计算所需分配内存大小，malloc需要手动计算
new返回的是对象类型的指针，malloc返回的是void*，之后进行类型转换
new分配失败会抛出异常，malloc分配失败返回的是NULL;
new是在freestore上分配内存，malloc堆上分配;

delete需要对象类型的指针，free是void*类型的指针;

## 虚函数的实现
