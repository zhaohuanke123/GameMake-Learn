# 基础部分

struct 和 class区别 -> 值类型和引用类型区别

引用类型数据存储在内存堆中，而内存单元中存放的是堆中存放的地址

| 值类型               | 引用类型         |
| -------------------- | ---------------- |
| System.ValueType     | System.Object    |
| 函数中的存储在栈内存 | 存储在堆内存     |
| 随函数调用自动释放的 | 由 GC 来自动释放 |
|                      |                  |
|                      |                  |

引出话题：堆栈内存结构，GC


## 重载和重写的区别

封装、继承、多态所处位置不同，重载在同类中，重写在父子类中。
定义方式不同，重载方法名相同参数列表不同，重写方法名和参数列表都相同。
调用方式不同，重载使用相同对象以不同参数调用，重写用不同对象以相同参数调用。
多态时机不同，重载时编译时多态，重写是运行时多态。


## 请描述Interface与抽象类之间的不同

1. 接口不是类 不能实例化 抽象类可以间接实例化
2. 接口是完全抽象 抽象类为部分抽象
3. 接口可以多继承 抽象类是单继承


## 构造函数是否能被重写？

构造器Constructor不能被继承，因此不能重写，但可以被重载


## 反射

C#支持反射，其基础就是元数据。

程序集 包含元数据和IL代码

元数据由三种元数据表构成：定义表，引用表和清单表。

1）定义表，包含了类型、属性、方法的定义。对应于上面示例中TypeDef/Field/Method等。

2）引用表，主要就是对引用的程序集内部的类型、属性、方法的描述。对应于上面示例中TypeRef/MemberRef等。

3）清单表，主要就是对程序集组成的那部分文件的信息。



## Task状态机的实现和⼯作机制是什么？

CPS全称是Continuation Passing Style，在.NET中，它会⾃动编译为： 

1. 将所有引⽤的局部变量做成闭包，放到⼀个隐藏的状态机的类中；
2. 将所有的await展开成⼀个状态号，有⼏个await就有⼏个状态号；
3. 每次执⾏完⼀个状态，都重复回调状态机的MoveNext⽅法，同时指定下⼀个状态号；MoveNext⽅法还需处理线程和异常等问题。

## await的作⽤和原理，并说明和GetResult()有什么区别？

从状态机的⻆度出发，await的本质是调⽤Task.GetAwaiter()的UnsafeOnCompleted(Action)回调，并
指定下⼀个状态号。

从多线程的⻆度出发，如果await的Task需要在新的线程上执⾏，该状态机的MoveNext()⽅法会⽴即返
回，此时，主线程被释放出来了，然后在UnsafeOnCompleted回调的action指定的线程上下⽂中继续
MoveNext()和下⼀个状态的代码。

⽽相⽐之下，GetResult()就是在当前线程上⽴即等待Task的完成，在Task完成前，当前线程不会释
放。 注意：Task也可能不⼀定在新的线程上执⾏，此时⽤GetResult()或者await就只有会不会创建状态
机的区别了
