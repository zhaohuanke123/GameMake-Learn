# UGUI使用以及优化

总结优化：

GPU上，CPU上，内存上

减少UI层级深度，Rebatch降低Depth计算开销

图集合批降drawCall
动静分离分Canvas减少网格重建

优化显隐
内存换Cpu:预加载、UI对象池
拆分UI，分时加载
图集优化
纹理压缩


减少OverDraw：

关闭全屏节面后面的UI

禁用不可见的摄像机输出

关闭大部分被遮挡的摄像机


## 原理与核心组件简介

Canvas 合批规则
depth计算
depth 材质 纹理 renderOrder排序，合并相邻元素到一网格

显示图片 需要构建网格 -> 放入图片纹理进行映射
优化：合并图集，材质球合并 ->  网格也一起合并 降低DrawCall

合并成一个网格了就是一个静止的模型了
如果我们移动了任何元素，或者销毁了任何元素，或者改变了任何元素的材质球参数，UGUI则会销毁这个网格，重新构建一个新的。
合并的最多的元素，拆分次数最少的UI，才能达到优秀的性能开销.

## MeshRender中material和sharedmaterial的区别？

改shared影响全部，运行时代码改会拷贝新的，内存占用

## Image和RawImage的区别?

RawImage 快，只能展示用，支持各种纹理
Image 支持裁剪平铺旋转，九宫格

## 如何在不同分辨率下保 持UI的一致性?

布局元素的Rect Transform -> 控制锚点使元素相对位置不变
Canvas的Canvas Scaler组件 -> Scale With Screen Size 根据屏幕分辨率裁剪或填充

## UGUI常用组件有哪些，具体实现是什么？

### Graphic Raycaster

图形碰撞测试组件
存在有效的碰撞体 统一使用射线碰撞测试来检测碰撞的元素
设置完全忽略输入的方式来彻底取消点击响应，指定阻止对某些layers进行相应

### EventTrigger

事件触发器，接受到输入事件，有各个回调接口
配合Graphic Raycaster 响应给输入事件系统

### Mask，RectMask2D

Mask 模板测试
Rect 顶点重构的方式剔除矩形区域外的部分

### 其他

可重写

按钮组件Button
切换组件Toggle
滚动条组件ScrollBar
滑动组件Slider
下拉框组件DropDown
视图组件ScrollView

## UGUI事件传递流程是什么样的？

事件系统 射线检测
![Button click](image.png)

IEventSystemHandler: 各种事件的触发接口
ExecuteEvents：静态类，执行各种Handler

EventSytem 每帧调用InputModule的Process，
获取点击位置下面的可相应事件的Handler并执行

事件体系组成：
◎监测器（Monito）
◎采集器（Collector）
◎派发器（Dispatcher）
◎响应器（Receiver）

## 什么是UI动静分离？如何优化？

把会动的UI元素放入专门为它们准备的Canvas合并节点上

移动缩放的时候，不再会重构静态部分的UI了。
在实际项目中静态的UI元素占UI的数量比较多，而动态的UI元素只是小部分

动静分离后，减少了不少的CPU在重绘和合并时的消耗。

## 为什么要拆分过大的UI？如何拆分？

UI过大，实例化，初始化时，消耗的CPU过大。
把隐藏的UI界面拆分出来，成为独立运作的界面，只在需要它们时才调用并实例化。
其次，如果界面内容还是很多，我们可以把2次显示的内容拆出来。
权衡加载速度与内存，过大的UI固然加载缓慢内存消耗大，但拆分成小个体时，如果小个体频繁加载和销毁，也同样会消耗过多CPU。 -> 做缓存

## 为什么要进行UI的预加载？如何进行UI预加载？

1. 在游戏开始前加载UI资源但不实例化，只是把资源加载到内存。
2. 在第一种方法的基础上，打开界面时CPU还是消耗太严重，那么就将UI实例化和初始化也提前到游戏开始前。

问题：预加载并没有削减CPU，CPU消耗的总量并没有发生变化。
只是把它们这些消耗分离了或者说提前了，拆分到了各个时间碎片里去
如果我们将这些预加载，集中在了某个位置，也同样会有强烈的卡顿感，因为CPU在这个点进行了集中的消耗。

## UGUI图在改变颜色或Alpha后，会导致Mesh重构和增加DrawCall吗？

直接修改Color会造成UI的重建,但不会产生额外的Draw Call,
而通过获取Material修改Shader里的_Color属性不会引起UI的重建但是会额外产生Draw Call。

创建自定义材质球，然后提前通知 UGUI 使用这个材质球进行渲染。
在动画中改变颜色和 Alpha 时，直接修改这个自定义材质球的参数，避免 Mesh 的重建。
这是一个有效的优化策略，它允许你控制渲染过程，并且可以显著减少因 UI 变化而产生的计算量。

## UI展示与关闭如何优化？

打开和关闭会消耗一定的CPU，打开时需要实例化和初始化，关闭需要销毁GameObject。

预加载
不销毁，只隐藏,隐藏方法 :

1. SetActive
2. 用坐标去做摄像机的渲染排除
3. 用层级Layout去做摄像机的排除操作
4. Canvas group alpha

内存换CPU，关闭界面时不减少内存，只减少了CPU的消耗。
显示所有节点的同时，UI网格需要重构，而移出屏幕则不需要重构网格。

## UI对象池如何运用？

用内存换CPU的策略

当程序中有重复实例化并不断销毁的对象时需要使用对象池进行优化。
销毁操作时使用对象池接口进行销毁。
场景结束时要及时销毁整个对象池，避免无意义的内存驻留。

## 如何针对高低端机进行优化？

UI贴图质量区分对待。
特效使用情况区分对待。
阴影使用情况区分对待。

降低阴影质量
使用面片代替
对部分模型使用简单的阴影面片代替，对另一部分比较重要的模型使用实时阴影渲染
我们将场景中的Render全部收集起来，把需要实时阴影计算的模型打开Render.receiveShadows选项，对另一些不需要实时阴影计算的模型关闭Render.receiveShadows选项，并选择使用简单阴影模型代替。

## UI图集拼接如何优化？

减少图集大小，减少图集数量，减少一次性加载图集数量，让游戏运行的更稳，更快。

充分利用图集空间

大图拆分开来拼接，或者把大图分离出去不放入图集内，而使用单独的图片做渲染。

图集大小标准在1024x1024，这样不仅在制作时要考虑让大小图充分利用空白空间，也让UI在加载时，只加载需要的图集，让加载速度更快。

把图集分类，例如，通常我们分为，
常用图集（里面包含了一些各个界面都会用到的常用图片），
功能类图集（比如大厅界面图集，背包界面图集，任务界面图集等）
，链接类图集（链接两种界面的图集，比如只在大厅界面与背包界面都会用的，特别需要拆分出来单独成为一张图集）

## 纹理压缩相关

### DXT

一种DirectDraw表面

DXT1格式主要适用于不具透明度的贴图或仅具一位Alpha的贴图（非完全透明则即完全不透明）

对于完全RGB565格式的贴图，DXT1具有4：1的压缩比，即平均每个像素颜色占4位

将每4×4个像素块视为一个压缩单位

压缩后的4×4个像素块占用64位，其中有2个16位的RGB颜色和16个2位索引

对于具有 DirectX 11 或更高级别 GPU 的设备，可保证支持 BC7 和 BC6H 格式，

推荐的压缩格式选择是：

RGB 纹理 - DXT1 4 位/像素。

 RGBA 纹理 - BC7（质量更高，压缩速度较慢）或 DXT5（压缩速度较快），均为 8 位/像素。

HDR 纹理 - BC6H 8 位/像素。

如果您需要在 PC 上支持 DirectX 10 类 GPU（2010 年之前的 NVIDIA GPU，2009 年之前的 AMD，2012 年之前的 Intel），则首选 DXT5（而不是 BC7），因为这些 GPU 不支持 BC7 和 BC6H。
